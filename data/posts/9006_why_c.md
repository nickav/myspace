---
title: "Why I Write C"
desc:  ""
date:  "2022-12-12 10:13:03"
image: "godrays_04.png"
author: "Nick Aversano"
draft: true
---

I started learning how to write my own game engines 5 years ago.
In doing so, I have learned a ton about how computers actually work.
Starting with C was a really great choice in some ways.
And it's been a really hard choice because I've encountered many things
I didn't understand. And a lot of things I didn't know I didn't know.
Now I know some things and I know I don't know more things.
One of the exiting things about programming is there's always more to learn!

This was not entirely accidental.
I decided to use C because I knew that lots of game engines are written in C.
I also knew that my code could run as fast as the hardware would allow.
And if I truly wanted to understand what all the things I was using are doing, then writing the code for it is a great way to do that.
If you want to prove to yourself that you learned something, explaining it to someone is a good litmus test. And explaining it to a computer is even better.

I also decided to take it one step further by not allowing myself to use many libraries.
At least for the base layer I only use the CRT (and that I could get rid of if needed, but I added it back in for portability!).
I do use some libraries, but I always am aware of what I am using.
I try to really understand what they do, so that if I needed to I could replace them.

What I learned to love about C is it gives you almost nothing by default.
You are in control of everything that happens.
In some sense, you're just about as close to the computer as you can actually get.
And you can even see the CPU instructions that run on your actual computer!

(A brief aside: as it turns out CPUs are more complicated these days, and there are
things called micro-ops which some instructions break down further into. But let's not get into that here!)

NOTE(nick): do a blog post about everything you know about CPUs

Here's a plug for the great https://uops.info/table.html

After writing many many "web apps" I started to feel overwhelmingly frustrated with that ecosystem.
Slow build times, 10k+ dependencies for a pretty crappy UX. Seems like a bad trade!

I wondered: what's actually going on under the hood of a browser?
I also wanted to get back into game development, but was extremely frustrated by
the now 5+ second build times of Game Maker Studio.
I wondered if I could bring hot loading to game making?
It should be able to reload things instantly!

Games are great in a lot of ways. They have for a long time been pushing the bounds of what computers can do, and paved way for the mainstream consumer GPU market that we have today!
Games have to do the job of what every application needs to do: getting a window up on the screen, getting user input, displaying the results and playing sound.
And then they have to actually build a fun game on top of that!
So it turned out that learning how to make game engines is also a great way to learn
how to build applications from scratch.

Especially because I decided to not use many tools, I had to learn how everything works.

To start I needed to build a base layer to pick myself up from.


TODO(nick): write a base layer post!

My base layer includes:
- Base types (`i32`, `u32`)
- Base macros
- Arenas
- Strings
- OS calls
- Arrays and Tables

Want a window to show up? Well, there's a lot of quirks with that.

Want graphics to show up on the screen? You're going to have to wrangle GPU APIs (not dissimilar to doing your taxes).

Want font rendering? That's a rabbit hole. At the very least, you have to write a font-atlas cache and space out all the glyphs.

Want sounds? You need to really care about the speed of that! And then not to mention sound mixing!

Want controller input? Well there's like 4 APIs and they all give slightly different, but overlaping information: XInput, DirectInput, ...

Oh yeah and also every one of these things has like anywhere from 2-5+ APIs from the Windows operating system! So which one do you pick?

You really appreciate everything when you have nothing.

